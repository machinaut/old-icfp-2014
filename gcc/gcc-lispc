#!/usr/bin/env python3

################ Lispy: Scheme Interpreter in Python

## (c) Peter Norvig, 2010; See http://norvig.com/lispy.html

import argparse
import io
import sys

class Program(object):
    MAIN = 1
    FUNCTION = 2

    def __init__(self, debug_level):
        self.total_if_count = 0
        self.debug_level = debug_level

        self.main_output = io.StringIO("")
        self.function_output = io.StringIO("")

    def output(self, region, s):
        if region == self.MAIN:
            f = self.main_output
        elif region == self.FUNCTION:
            f = self.function_output

        print(s, file=f)

    def debug_comment(self, out, level, comment):
        if self.debug_level >= level:
            self.output(out, "; %s" % comment)

    def emit(self):
        print("; main program")
        print(self.main_output.getvalue())
        print("; functions")
        print(self.function_output.getvalue())

################ Instructions

class Instruction(object):
    def __init__(self, program, region, op1=None, op2=None):
        self.program = program
        self.region = region
        self.op1 = op1
        self.op2 = op2

        if op1 is None and op2 is not None:
            raise ValueError("'%s' got a second operand, but not a first" %
                                (self.name))

        if op2 is not None:
            passed_ops = 2
        elif op1 is not None:
            passed_ops = 1
        else:
            passed_ops = 0

        if passed_ops != self.ops:
            raise ValueError("'%s' expected %d ops, found %d" %
                    (self.name, self.ops, passed_ops))

    def __repr__(self):
        r = self.name

        if self.op1 is not None:
            r += " " + str(self.op1)

        if self.op2 is not None:
            r += " " + str(self.op2)

        return r

    def emit(self):
        self.program.output(self.region, str(self))

class Add(Instruction):
    name = 'ADD'
    ops = 0

class Sub(Instruction):
    name = 'SUB'
    ops = 0

class Mul(Instruction):
    name = 'MUL'
    ops = 0

class Div(Instruction):
    name = 'DIV'
    ops = 0

class Cons(Instruction):
    name = 'CONS'
    ops = 0

class Car(Instruction):
    name = 'CAR'
    ops = 0

class Cdr(Instruction):
    name = 'CDR'
    ops = 0

class Ceq(Instruction):
    name = 'CEQ'
    ops = 0

class Cgt(Instruction):
    name = 'CGT'
    ops = 0

class Cgte(Instruction):
    name = 'CGTE'
    ops = 0

class Atom(Instruction):
    name = 'ATOM'
    ops = 0

class Ldc(Instruction):
    name = 'LDC'
    ops = 1

class Ld(Instruction):
    name = 'LD'
    ops = 2

class St(Instruction):
    name = 'ST'
    ops = 2

class Ldf(Instruction):
    name = 'LDF'
    ops = 1

class Ap(Instruction):
    name = 'AP'
    ops = 1

class Rtn(Instruction):
    name = 'RTN'
    ops = 0

class Sel(Instruction):
    name = 'SEL'
    ops = 2

class Join(Instruction):
    name = 'JOIN'
    ops = 0

class Builtin(object):
    def __init__(self, instr):
        self.instr = instr

################ Symbol, Env classes

Symbol = str

class Env(dict):
    "An environment: a dict of {'var':val} pairs, with an outer Env."
    def __init__(self, outer=None):
        self.outer = outer

    def find(self, var):
        "Find the innermost Env where var appears."
        return self if var in self else self.outer.find(var)

def add_globals(env):
    env.update({
        '+':    Builtin(Add),
        '-':    Builtin(Sub),
        '*':    Builtin(Mul),
        '/':    Builtin(Div),
        '==':   Builtin(Ceq),
        '>':    Builtin(Cgt),
        '>=':   Builtin(Cgte),
        'atom': Builtin(Atom),
        'cons': Builtin(Cons),
        'car':  Builtin(Car),
        'cdr':  Builtin(Cdr),
    })
    return env

global_env = add_globals(Env())

isa = isinstance

################ Functions, Labels

class Function(object):
    def __init__(self, name, num_args):
        self.name = name
        self.num_args = num_args

class Label(object):
    def __init__(self, name, program, region):
        self.name = name
        self.program = program
        self.region = region

    def emit(self):
        self.program.output(self.region, "%s:" % self.name)

    def __repr__(self):
        return self.name

################ Expressions

class Expression(object):
    def __init__(self, expression, program, env=global_env, region=Program.MAIN):
        self.program = program
        self.expression = expression
        self.env = env
        self.region = region

        self.program.debug_comment(region, 3, "New expression: %s" % expression)

    def subexpression(self, exp, env=None, region=None):
        if env is None:
            env = self.env
        if region is None:
            region = self.region

        return Expression(exp, self.program, env, region)

    def instruction(self, instr, op1=None, op2=None, region=None):
        if region is None:
            region = self.region

        return instr(self.program, region, op1=op1, op2=op2)

    def label(self, name, region=None):
        if region is None:
            region = self.region

        return Label(name, self.program, region)

    def define_func(self, name, args, body):
        self.program.debug_comment(Program.FUNCTION, 1, "function %s %s" % (name, to_string(args)))
        self.label(name, region=Program.FUNCTION).emit()

        func = Function(name, len(args))
        self.env[name] = func

        local_env = Env(outer=self.env)

        for i, a in enumerate(args):
            local_env[a] = self.instruction(Ld, 0, i, region=Program.FUNCTION)

        # This gives us parent frames from the point of function
        body = self.subexpression(body, env=local_env, region=Program.FUNCTION)
        body.emit()

        self.instruction(Rtn, region=Program.FUNCTION).emit()

    def emit_if(self, test, conseq, alt):
        true_label = self.label("if_true_%d" % self.program.total_if_count)
        false_label = self.label("if_false_%d" % self.program.total_if_count)
        after_label = self.label("if_after_%d" % self.program.total_if_count)
        self.program.total_if_count += 1

        # Execute the test condition
        test = self.subexpression(test)
        test.emit()

        # Jump to true or false case
        self.instruction(Sel, true_label, false_label).emit()

        # After true or false case completion, jump to end
        self.instruction(Ldc, 1).emit()
        self.instruction(Sel, after_label, 0).emit()

        # True case, then join back to above
        true_label.emit()
        conseq = self.subexpression(conseq)
        conseq.emit()
        self.instruction(Join).emit()

        # False case, then join back to above
        false_label.emit()
        alt = self.subexpression(alt)
        alt.emit()
        self.instruction(Join).emit()

        # When done, jump to next instructions
        after_label.emit()

    def emit(self):
        "Evaluate an expression in an environment."
        x = self.expression
        self.program.debug_comment(self.region, 3, "emit(%r)" % x)
        if isa(x, Symbol):             # variable reference
            s = self.env.find(x)[x]
            if isa(s, Instruction):
                s.emit()
            return s
        elif not isa(x, list):         # constant literal
            self.instruction(Ldc, x).emit()
            return
        elif x[0] == 'if':             # (if test conseq alt)
            (_, test, conseq, alt) = x
            self.emit_if(test, conseq, alt)
        #elif x[0] == 'set!':           # (set! var exp)
        #    (_, var, exp) = x
        #    env.find(var)[var] = eval(exp, env)
        #elif x[0] == 'define':         # (define var exp)
        #    (_, var, exp) = x
        #    #env[var] = eval(exp, env)
        #    eval(exp, env)
        #    print(St(0, 0))
        #    return
        #elif x[0] == 'lambda':         # (lambda (var*) exp)
        #    (_, vars, exp) = x
        #    return lambda *args: eval(exp, Env(vars, args, env))
        #elif x[0] == 'begin':          # (begin exp*)
        #    for exp in x[1:]:
        #        val = eval(exp, env)
        #    return val
        elif x[0] == 'defun':           # Function definition
            # (defun name (a1 a2) (body))
            assert(len(x) == 4)
            (_, name, args, body) = x
            self.define_func(name, args, body)
        else:                          # (proc exp*)
            self.program.debug_comment(self.region, 3, "proc '%s'" % x[0])
            exps = [self.subexpression(exp).emit() for exp in x]
            proc = exps.pop(0)
            if isa(proc, Builtin):
                self.instruction(proc.instr).emit()
            elif isa(proc, Function):
                self.instruction(Ldf, proc.name).emit()
                self.instruction(Ap, proc.num_args).emit()
            return

################ read, and user interaction

def read(s):
    "Read a Scheme expression from a string."
    return read_from(tokenize(s))

def tokenize(s):
    "Convert a string into a list of tokens."
    news = []
    for line in s.split('\n'):
        if len(line) == 0: continue
        if line[0] == '#': continue # pass on comments
        news.append(line)
    s = ''.join(news)
    return s.replace('(',' ( ').replace(')',' ) ').split()

def read_from(tokens):
    "Read an expression from a sequence of tokens."
    if len(tokens) == 0:
        raise SyntaxError('unexpected EOF while reading')
    token = tokens.pop(0)
    if '(' == token:
        L = []
        while tokens[0] != ')':
            L.append(read_from(tokens))
        tokens.pop(0) # pop off ')'
        return L
    elif ')' == token:
        raise SyntaxError('unexpected )')
    else:
        return atom(token)

def atom(token):
    "Numbers become numbers; every other token is a symbol."
    try: return int(token)
    except ValueError:
        return Symbol(token)

def to_string(exp):
    "Convert a Python object back into a Lisp-readable string."
    return '('+' '.join(map(to_string, exp))+')' if isa(exp, list) else str(exp)

if __name__ == "__main__":
    parser = argparse.ArgumentParser("Compile λ-LISP programs")
    parser.add_argument('source', nargs='?', default='/dev/stdin', help="File to compile (default=stdin)")
    parser.add_argument('-v', '--verbose', action='count', default=0, help="Increase verbosity")
    args = parser.parse_args()

    with open(args.source) as source_file:
        source = source_file.read()

    program = Program(args.verbose)
    tokenized = tokenize(source)

    while tokenized:
        e = read_from(tokenized)
        expression = Expression(e, program)
        expression.emit()

    # Return at the end of the main program,
    if program.main_output.getvalue():
        program.debug_comment(Program.MAIN, 2, "Return from main program")
        Rtn(program, Program.MAIN).emit()

    program.emit()
